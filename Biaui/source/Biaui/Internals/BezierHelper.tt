<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>

// ReSharper disable All
// <auto-generated />

using System;
using System.Runtime.CompilerServices;

namespace Biaui.Internals
{
<#
foreach (var typeName in new[]{"float", "double"})
{
#>
    public static class BezierHelper_<#= typeName #>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= typeName #> Bezier(<#= typeName #> x1, <#= typeName #> x2, <#= typeName #> x3, <#= typeName #> x4, <#= typeName #> t)
        {
            var mt2 = ((<#= typeName #>)1 - t) * ((<#= typeName #>)1 - t);
            var mt3 = mt2 * ((<#= typeName #>)1 - t);
            var pt2 = t * t;
            var pt3 = pt2 * t;

            return mt3 * x1 + (<#= typeName #>)3 * mt2 * t * x2 + (<#= typeName #>)3 * ((<#= typeName #>)1 - t) * pt2 * x3 + pt3 * x4;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> A(<#= typeName #> p0, <#= typeName #> p1, <#= typeName #> p2, <#= typeName #> p3)
            => (<#= typeName #>)3 * p3 - (<#= typeName #>)9 * p2 + (<#= typeName #>)9 * p1 - (<#= typeName #>)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> B(<#= typeName #> p0, <#= typeName #> p1, <#= typeName #> p2)
            => (<#= typeName #>)6 * p2 - (<#= typeName #>)12 * p1 + (<#= typeName #>)6 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> C(<#= typeName #> p0, <#= typeName #> p1)
            => (<#= typeName #>)3 * p1 - (<#= typeName #>)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> Determinant(<#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
            => (<#= typeName #>)Math.Pow(b, (<#= typeName #>)2) - (<#= typeName #>)4 * a * c;

        // ReSharper disable InconsistentNaming
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> SolveP(<#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
            => (<#= typeName #>)(-b + (<#= typeName #>)Math.Sqrt(b * b - (<#= typeName #>)4 * a * c)) / ((<#= typeName #>)2 * a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static <#= typeName #> SolveM(<#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
            => (<#= typeName #>)(-b + (<#= typeName #>)Math.Sqrt(b * b - (<#= typeName #>)4 * a * c) * (<#= typeName #>)-1) / ((<#= typeName #>)2 * a);

        private static int Solve(Span<<#= typeName #>> result, <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
        {
            var d = Determinant(a, b, c);

            if (d <= 0)
                return 0;

            if (NumberHelper.AreCloseZero(a))
            {
                result[0] = -c / b;
                return 1;
            }

            if (NumberHelper.AreCloseZero(d))
            {
                result[0] = SolveP(a, b, c);
                return 1;
            }

            result[0] = SolveP(a, b, c);
            result[1] = SolveM(a, b, c);
            return 2;
        }
    }  

<#
}
#>
}
