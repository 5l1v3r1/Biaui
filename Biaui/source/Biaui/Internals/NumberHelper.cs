
// ReSharper disable All
// <auto-generated />

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace Biaui.Internals
{
    internal static class NumberHelper
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float DistanceSq(in this ValueTuple<ImmutableVec2_float, ImmutableVec2_float> pos)
        {
            var w = pos.Item1.X - pos.Item2.X;
            var h = pos.Item1.Y - pos.Item2.Y;

            return w * w + h * h;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AreClose(float value1, float value2)
        {
            const float EPSILON = (float)1.4e-45;

            if (value1 == value2)
                return true;

            var eps = (Math.Abs(value1) + Math.Abs(value2) + 10.0f) * EPSILON;
            var delta = value1 - value2;

            return (-eps < delta) && (eps > delta);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AreCloseZero(float value1)
        {
            const float EPSILON = (float)1.4e-45;

            if (value1 == 0f)
                return true;

            var eps = (Math.Abs(value1) + 10.0f) * EPSILON;
            var delta = value1;

            return (-eps < delta) && (eps > delta);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Clamp01(float value)
        {
            if (value <= 0f)
                return 0f;

            if (value >= 1f)
                return 1f;

            return value;
        }

        /// <summary>
        /// value, min, max
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Clamp(in this ValueTuple<float, float, float> value)
        {
            Debug.Assert(value.Item2 <= value.Item3);

            if (value.Item1 < value.Item2)
                return value.Item2;

            if (value.Item1 > value.Item3)
                return value.Item3;

            return value.Item1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static (float Min, float Max) MinMax(in this ValueTuple<float, float> value)
            => value.Item1 < value.Item2
                ? (value.Item1, value.Item2)
                : (value.Item2, value.Item1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Max(in this ValueTuple<float, float> value)
            => value.Item1 > value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Min(in this ValueTuple<float, float> value)
            => value.Item1 < value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Max(in this ValueTuple<float, float, float> value)
             => ((value.Item1, value.Item2).Max(), value.Item3).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Min(in this ValueTuple<float, float, float> value)
             => ((value.Item1, value.Item2).Min(), value.Item3).Min();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Max(in this ValueTuple<float, float, float, float> value)
             => (((value.Item1, value.Item2).Max(), value.Item3).Max(), value.Item4).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static float Min(in this ValueTuple<float, float, float, float> value)
             => (((value.Item1, value.Item2).Min(), value.Item3).Min(), value.Item4).Min();
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double DistanceSq(in this ValueTuple<ImmutableVec2_double, ImmutableVec2_double> pos)
        {
            var w = pos.Item1.X - pos.Item2.X;
            var h = pos.Item1.Y - pos.Item2.Y;

            return w * w + h * h;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AreClose(double value1, double value2)
        {
            const double EPSILON = 2.2204460492503131e-016;

            if (value1 == value2)
                return true;

            var eps = (Math.Abs(value1) + Math.Abs(value2) + 10.0d) * EPSILON;
            var delta = value1 - value2;

            return (-eps < delta) && (eps > delta);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AreCloseZero(double value1)
        {
            const double EPSILON = 2.2204460492503131e-016;

            if (value1 == 0d)
                return true;

            var eps = (Math.Abs(value1) + 10.0d) * EPSILON;
            var delta = value1;

            return (-eps < delta) && (eps > delta);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Clamp01(double value)
        {
            if (value <= 0d)
                return 0d;

            if (value >= 1d)
                return 1d;

            return value;
        }

        /// <summary>
        /// value, min, max
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Clamp(in this ValueTuple<double, double, double> value)
        {
            Debug.Assert(value.Item2 <= value.Item3);

            if (value.Item1 < value.Item2)
                return value.Item2;

            if (value.Item1 > value.Item3)
                return value.Item3;

            return value.Item1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static (double Min, double Max) MinMax(in this ValueTuple<double, double> value)
            => value.Item1 < value.Item2
                ? (value.Item1, value.Item2)
                : (value.Item2, value.Item1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Max(in this ValueTuple<double, double> value)
            => value.Item1 > value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Min(in this ValueTuple<double, double> value)
            => value.Item1 < value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Max(in this ValueTuple<double, double, double> value)
             => ((value.Item1, value.Item2).Max(), value.Item3).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Min(in this ValueTuple<double, double, double> value)
             => ((value.Item1, value.Item2).Min(), value.Item3).Min();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Max(in this ValueTuple<double, double, double, double> value)
             => (((value.Item1, value.Item2).Max(), value.Item3).Max(), value.Item4).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static double Min(in this ValueTuple<double, double, double, double> value)
             => (((value.Item1, value.Item2).Min(), value.Item3).Min(), value.Item4).Min();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Clamp01(int value)
        {
            if (value <= 0)
                return 0;

            if (value >= 1)
                return 1;

            return value;
        }

        /// <summary>
        /// value, min, max
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Clamp(in this ValueTuple<int, int, int> value)
        {
            Debug.Assert(value.Item2 <= value.Item3);

            if (value.Item1 < value.Item2)
                return value.Item2;

            if (value.Item1 > value.Item3)
                return value.Item3;

            return value.Item1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static (int Min, int Max) MinMax(in this ValueTuple<int, int> value)
            => value.Item1 < value.Item2
                ? (value.Item1, value.Item2)
                : (value.Item2, value.Item1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Max(in this ValueTuple<int, int> value)
            => value.Item1 > value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Min(in this ValueTuple<int, int> value)
            => value.Item1 < value.Item2
                ? value.Item1
                : value.Item2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Max(in this ValueTuple<int, int, int> value)
             => ((value.Item1, value.Item2).Max(), value.Item3).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Min(in this ValueTuple<int, int, int> value)
             => ((value.Item1, value.Item2).Min(), value.Item3).Min();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Max(in this ValueTuple<int, int, int, int> value)
             => (((value.Item1, value.Item2).Max(), value.Item3).Max(), value.Item4).Max();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int Min(in this ValueTuple<int, int, int, int> value)
             => (((value.Item1, value.Item2).Min(), value.Item3).Min(), value.Item4).Min();
    }
}
