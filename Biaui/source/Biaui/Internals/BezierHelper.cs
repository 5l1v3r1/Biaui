
// ReSharper disable All
// <auto-generated />

using System;
using System.Runtime.CompilerServices;

namespace Biaui.Internals
{
    public static class BezierHelper_float
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Bezier(float x1, float x2, float x3, float x4, float t)
        {
            var mt2 = ((float)1 - t) * ((float)1 - t);
            var mt3 = mt2 * ((float)1 - t);
            var pt2 = t * t;
            var pt3 = pt2 * t;

            return mt3 * x1 + (float)3 * mt2 * t * x2 + (float)3 * ((float)1 - t) * pt2 * x3 + pt3 * x4;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float A(float p0, float p1, float p2, float p3)
            => (float)3 * p3 - (float)9 * p2 + (float)9 * p1 - (float)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float B(float p0, float p1, float p2)
            => (float)6 * p2 - (float)12 * p1 + (float)6 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float C(float p0, float p1)
            => (float)3 * p1 - (float)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float Determinant(float a, float b, float c)
            => (float)Math.Pow(b, (float)2) - (float)4 * a * c;

        // ReSharper disable InconsistentNaming
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float SolveP(float a, float b, float c)
            => (float)(-b + (float)Math.Sqrt(b * b - (float)4 * a * c)) / ((float)2 * a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float SolveM(float a, float b, float c)
            => (float)(-b + (float)Math.Sqrt(b * b - (float)4 * a * c) * (float)-1) / ((float)2 * a);

        private static int Solve(Span<float> result, float a, float b, float c)
        {
            var d = Determinant(a, b, c);

            if (d <= 0)
                return 0;

            if (NumberHelper.AreCloseZero(a))
            {
                result[0] = -c / b;
                return 1;
            }

            if (NumberHelper.AreCloseZero(d))
            {
                result[0] = SolveP(a, b, c);
                return 1;
            }

            result[0] = SolveP(a, b, c);
            result[1] = SolveM(a, b, c);
            return 2;
        }
    }  

    public static class BezierHelper_double
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Bezier(double x1, double x2, double x3, double x4, double t)
        {
            var mt2 = ((double)1 - t) * ((double)1 - t);
            var mt3 = mt2 * ((double)1 - t);
            var pt2 = t * t;
            var pt3 = pt2 * t;

            return mt3 * x1 + (double)3 * mt2 * t * x2 + (double)3 * ((double)1 - t) * pt2 * x3 + pt3 * x4;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double A(double p0, double p1, double p2, double p3)
            => (double)3 * p3 - (double)9 * p2 + (double)9 * p1 - (double)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double B(double p0, double p1, double p2)
            => (double)6 * p2 - (double)12 * p1 + (double)6 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double C(double p0, double p1)
            => (double)3 * p1 - (double)3 * p0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double Determinant(double a, double b, double c)
            => (double)Math.Pow(b, (double)2) - (double)4 * a * c;

        // ReSharper disable InconsistentNaming
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double SolveP(double a, double b, double c)
            => (double)(-b + (double)Math.Sqrt(b * b - (double)4 * a * c)) / ((double)2 * a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double SolveM(double a, double b, double c)
            => (double)(-b + (double)Math.Sqrt(b * b - (double)4 * a * c) * (double)-1) / ((double)2 * a);

        private static int Solve(Span<double> result, double a, double b, double c)
        {
            var d = Determinant(a, b, c);

            if (d <= 0)
                return 0;

            if (NumberHelper.AreCloseZero(a))
            {
                result[0] = -c / b;
                return 1;
            }

            if (NumberHelper.AreCloseZero(d))
            {
                result[0] = SolveP(a, b, c);
                return 1;
            }

            result[0] = SolveP(a, b, c);
            result[1] = SolveM(a, b, c);
            return 2;
        }
    }  

}
